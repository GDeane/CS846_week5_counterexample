# Week 5 Feedback:

**Authors:** [Gavin Deane, Artemiy Vishnyakov, Savira Umar]

## 1. Counterexample Problems

### Problem A_1: Summarize Legacy Code [Gavin Deane]

**Task Description:**

Generate a clear and concise summary of the javascript processOrder function described in processOrder_example.js

**Starter Code:**

The function and example test file is found in https://github.com/GDeane/CS846_week5_counterexample/tree/main/Week5/A_1.

> A note on GenAI contribution: The "legacy code" and test file was generated using GitHub Copilot: GPT-5.1-Codex-Max

---

### 2. Guidelines that didn't work for Problem A_1

#### Guideline 2: Explicitly Constrain Summary Length

The original guideline assumes that brevity improves clarity and reduces "fluff" (like error handling).
However, in complex code such as legacy enterprise code, the "how" and the "edge cases" become vital pieces of
information.

By strictly constraining the length to 20 words or less, the LLM is forced to aggresively abstract away complexity. This
causes the model to omit implementation details such as code side-effects that are necessary for a developer to know.

A prudent use case for using generative AI to summarize code is in understanding and debugging legacy code. This type of
code is
often overloaded and side-effect heavy, meaning a longer summary is necessary for correctness, safety, and
understanding.

Constraining the summary length in this case can cause an oversimplified understanding of the code, leading to dangerous
assumptions.

**Prompt and Context:**

Context Given: processOrder_example.js test_processOrder_example.js

> "Please generate a brief description in one sentence of the function processOrder (max 20 words)."

**Solution or Output generated by GitHub Copilot (Raptor Mini):**

Processes an order by charging payment, sending email, updating caches and audit logs, and handling offline/retry flows.

**Why this is sub-optimal:**

While this summary could be considered concise, it is **dangerous** due to it omitting several 'invisible' behaviors of
the above legacy code.

In reality, this is very "dirty" legacy code with many high-risk side effects, such as:

- the function quietly mutates the overrides object passed to it, something the developer may not know about.
- The function uses `fs.readFileSync` and `fs.appendFileSync`, which block the entire event loop in Node.js and will
  freeze
  the server everytime it writes an audit log or reads the config.
- The function is **not stateless**. It modifies globalState when called, and its behavior depends on previous calls.

A good summary of this code should act as a warning label for developers that notes these kinds of obvious side effects.

---

### 3. New and Updated Guidelines that worked for Problem A_1

#### Guideline 2 (Revised): Context-Aware Length Scaling

**Description:**

Ask the LLM to be clear and concise (high output information density), rather than imposing a hard word limit.
Summaries should prioritize **functional completeness** over strict word counts for sensitive tasks.

**Reasoning:**

Strict constraints lead to over-generalization, where specific logic is replaced by vague verbs. This is dangerous
when the true complexity is much higher than a 20-word constraint would permit.

**Prompt and Context:**

Context Given: processOrder_example.js test_processOrder_example.js

> "Summarize the processOrder function in a clear and concise manner (max 20 words). Exception: If the code includes
> non-standard
> side-effects, you must add a 'Note' section highlighting each of these risks."

**Solution or Output generated by GitHub Copilot (Raptor Mini):**

Summary ✅

- Processes an order: loads config, charges payment, sends email, caches/audits, queues work, and returns via
  callback. (16 words)

`Note ⚠️:

- **Mutates global state (globalState):** updates lastOrderId and increments retryCount — can leak across calls/tests.
- **Mutates caller argument (overrides):** adds _touchedAt and meta.startedBy — unexpected external mutation.
- **Synchronous disk I/O (fs.readFileSync, appendFileSync):** blocks the event loop and may degrade performance.
- **Audit side-channel:** writes START before success and DONE later — can produce inconsistent or misleading audit
  records.
- **Delayed post-callback effects (setTimeout):** updates cache, metrics, and audit after callback returns — state
  changes occur asynchronously.
- **External side-effects:** calls paymentGateway.charge, emailClient.send, and queue.push — depends on/affects external
  systems and retries.
- **Environment-dependent behavior:** uses process.env and fallback config, altering behavior based on runtime
  environment.
  `

**Result:**

The summary is longer, but it is closer to **optimal** because it captures the "hidden" behavior that a developer must
know to avoid introducing further bugs. Any developer I know would prefer

---

### Problem B_1: Document file using existing code style [Artemiy Vishnyakov]

**Task Description:**

Generate documentation for the pool.h file in Week5/ExampleProblemA/Artifacts

**Starter Code:**

The relevant files are found at https://github.com/GDeane/CS846_week5_counterexample/tree/main/Week5/B_1.

> A note on GenAI contribution: Example problem code was partially created using GitHub Copilot Raptor Mini

---

### 2. Guidelines that didn't work for Problem B_1

#### Guideline 1: Provide Project-Specific Examples of Code Summaries and Context for functions/files

**Prompt and context:**

> Our project's documentation style: pool_internal.h
> Document this in pool.h
> void pool_free(MemoryPool* pool, void* ptr);

**Solution or Output generated by GitHub Copilot (Raptor Mini):**

> /**
> * @brief Returns a previously allocated block to the pool.
> *
> * Returns a block previously obtained via pool_alloc() back to the pool for reuse.
> * If ptr is NULL the function does nothing. This function is thread-safe and
> * will acquire the pool's internal lock when updating pool state.
> *
> * @param pool Memory pool to return the block to (must be initialized via pool_init())
> * @param ptr Pointer previously returned by pool_alloc(), or NULL
> * @return None
> *
> * @pre pool initialized via pool_init(); if non-NULL, ptr must be a pointer
> *      previously returned by pool_alloc() and not already freed
> * @exceptsafe No-throw
    > */

**Why this is sub-optimal:**
Though the documentation looks correct it has false details which are copied from pool_internal and do not reflect the
true implementation. It also leaks details about the internal file functions through the comment.

---

### 3. New and Updated Guidelines that worked for Problem B_1

#### Guideline 7: Enforce strict separation between access levels of files, ideally using separate chats and repositories.

**Description:**

When working with sensitive data: Limit what information the LLM can read and reference when generating a response.
Ideally have a repository level separation but at minimum have the prompt reference the fact that the internal file
details cannot be leaked.

**Reasoning:**

LLMs tend to go for the easiest answer based on recently read data and thus are prone to repeat the confidential file if
there is a pattern that matches between the public facing and private files.

**Example**

Separate repositories for differing levels of access. A note on the sensitivity level of example files.

**Prompt and context:**

> Our project's documentation style: pool_internal.h
> Document this in pool.h
> void pool_free(MemoryPool* pool, void* ptr);
> Note that pool_internal.h is an internal file and must not be leaked. Do not copy internal or implementation specific
> details.

**Solution or Output generated by GitHub Copilot (Raptor Mini):**

> /**
> * @brief Return a previously allocated block to the pool.
> *
> * The block becomes available for future allocations. If ptr is NULL or does not
> * belong to the specified pool, the function has no effect.
> *
> * @param pool Memory pool to return the block to
> * @param ptr Pointer previously obtained from pool_alloc (may be NULL)
> * @return None
> *
> * @pre pool must be initialized via pool_init()
> * @exceptsafe No-throw guarantee
    > */
    `

**Result:**

With the added note explaining that pool_internal.h is internal the output documentation does not assume details about
the similarly named function and does not leak details about the internal file. The same situation can be observed with
a larger example in example_long.txt

---

### Problem C_1: [Title] [Savira Umar]

**Task Description:**  
Describe the task clearly and precisely.

**Starter Code:**  
// Include all necessary starter code here or in a repo and share the link here.

---

### 2. Guidelines that didn't work for Problem C_1

#### Guideline 1: [Title]

**Prompt and Context:**  
State the prompt and context that you gave to GitHub Copilot to implement that guideline.

**Solution or Output generated by GitHub Copilot:**  
Give the answer here generated by GitHub Copilot for the counterexaple that you think is not the correct/optimal answer.

...

---

### 3. New and Updated Guidelines that worked for Problem C_1

#### Guideline 1: [Title]

**Prompt and Context:**  
State the prompt and context that you gave to GitHub Copilot to implement that guideline.

**Solution or Output generated by GitHub Copilot:**  
Give the answer here generated by GitHub Copilot for the counterexaple that you think is the correct/optimal answer.

...

---